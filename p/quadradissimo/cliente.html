<!DOCTYPE html>
<html class="h-100">
<head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Quadrad√≠ssimo - Cliente</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css"></head>
<body class="h-100 m-0 p-0"><canvas class="w-100 h-100 d-block"></canvas><script>

// Define a URL base dependendo do ambiente
const wsURL = (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1")
    ? "ws://localhost:8080" 
    : "wss://furmigueiro.cyou/ws/";

const ws = new WebSocket(wsURL);

ws.onopen = () => console.log("Conectado ao servidor WebSocket!");//entrou

let aberto = false;

ws.addEventListener("open", e => {
  aberto = true;
  
});

//ws.send(m); enviar
let meuId = null

ws.onmessage = e => {

  const data = JSON.parse(e.data)

  if(data.type === "START"){
    meuId = data.id
    players.prota.id = meuId
  }

  // atualiza√ß√£o de players
  if(data.type === "UPDATE"){
    const inimigosTemp = [];
for (const p of data.players) {
      if (p.id === players.prota.id) {
        // üî• aqui sim voc√™ atualiza o prota
        players.prota.x = p.attributos.x;
        players.prota.y = p.attributos.y;
        players.prota.hp = p.attributos.hp;
        players.prota.maxHp = p.attributos.maxHp;
        players.prota.tamanho = p.attributos.tamanho;
      } else {
        // üî• aqui voc√™ guarda inimigos
        inimigosTemp.push(p);
      }
    }

    players.inimigo = inimigosTemp;
  }
}


//canvas
function resizeCanvasToDisplaySize(canva) {
    const dpr = window.devicePixelRatio; // Propor√ß√£o de pixels do dispositivo
    const displayWidth = Math.round(canva.clientWidth * dpr);
    const displayHeight = Math.round(canva.clientHeight * dpr);

    if (canva.width !== displayWidth || canva.height !== displayHeight) {
        canva.width = displayWidth;
        canva.height = displayHeight;
    }
}

const canva = document.getElementsByTagName('canvas')[0]
resizeCanvasToDisplaySize(canva);
const d = canva.getContext("2d")
//teclas üòé
let key = {}
window.addEventListener("keydown", e =>{
  key[e.key.toLowerCase()] = true;
})
window.addEventListener("keyup", e =>{
  key[e.key.toLowerCase()] = false;
})

//playerProtagonista
const nome = prompt("Digite seu nome:", "Jogador");

players = {
  prota: {
    x: null,
    y: null,
    nome: nome,
    hp: 10,
    maxHp: null,
    id: meuId,
    tamanho: 50
  }
}

function gameLoop(){
  // 1. Limpeza
  d.setTransform(1, 0, 0, 1, 0, 0);
  d.clearRect(0, 0, canva.width, canva.height);

  // Fundo fixo (opcional)
  d.fillStyle = "lightgrey";
  d.fillRect(0, 0, canva.width, canva.height);

  // --- CAMADA DO MUNDO (Move com a c√¢mera) ---
  let camX = 0;
  let camY = 0;

  if(players.prota.x !== null){
    // Calcula a c√¢mera
    camX = players.prota.x - (canva.width / 2) + 25;
    camY = players.prota.y - (canva.height / 2) + 25;

    // Aplica o movimento
    d.translate(-camX, -camY);
  }

  // Desenha coisas do mundo
  DesenharGrid();
  DesenharInimigos(); // Desenha os quadrados normais quando vis√≠veis
  DesenharProta();

  // --- CAMADA DE UI (Fixa na tela) ---
  
  // IMPORTANTE: Resetamos a transforma√ß√£o para desenhar na tela do jogador
  d.setTransform(1, 0, 0, 1, 0, 0);

  // Passamos o camX e camY calculados l√° em cima para saber a matem√°tica
  DesenharIndicadores(camX, camY);
  
  requestAnimationFrame(gameLoop);
}
function DesenharGrid() {
    d.strokeStyle = "black"; // Cor da linha
    d.lineWidth = 1;

    // Define o tamanho da c√©lula da grade
    const gridSize = 100; 

    // Precisamos saber onde a c√¢mera "come√ßa" e "termina" para desenhar o grid s√≥ onde a gente v√™
    // Mas para simplificar, vamos desenhar baseado na posi√ß√£o do player
    if(players.prota.x === null) return;

    // Pega o arredondamento da posi√ß√£o do player para alinhar a grade
    const startX = Math.floor((players.prota.x - canva.width) / gridSize) * gridSize;
    const endX = startX + canva.width * 2;
    
    const startY = Math.floor((players.prota.y - canva.height) / gridSize) * gridSize;
    const endY = startY + canva.height * 2;

    d.beginPath();
    
    // Linhas Verticais
    for (let x = startX; x <= endX; x += gridSize) {
        d.moveTo(x, startY);
        d.lineTo(x, endY);
    }

    // Linhas Horizontais
    for (let y = startY; y <= endY; y += gridSize) {
        d.moveTo(startX, y);
        d.lineTo(endX, y);
    }
    
    d.stroke();
}
function DesenharIndicadores(camX, camY) {
  if (!players.inimigo) return;

  const padding = 40;
  const cx = canva.width / 2;
  const cy = canva.height / 2;

  for (const enemy of players.inimigo) {
    const attr = enemy.attributos;

    const screenX = attr.x - camX;
    const screenY = attr.y - camY;

    const estaFora = 
      screenX < 0 || 
      screenX > canva.width || 
      screenY < 0 || 
      screenY > canva.height;

    if (estaFora) {
      let arrowX = Math.max(padding, Math.min(canva.width - padding, screenX));
      let arrowY = Math.max(padding, Math.min(canva.height - padding, screenY));

      const angle = Math.atan2(screenY - cy, screenX - cx);

      d.save();
      
      d.translate(arrowX, arrowY);
      d.rotate(angle);

      d.fillStyle = "red";
      d.beginPath();
      d.moveTo(10, 0);
      d.lineTo(-10, 10);
      d.lineTo(-10, -10);
      d.fill();

      d.restore();
    }
  }
}

  setInterval(()=>{
    if (players.prota.id) EnviarEstado()
  }, 100)

function DesenharProta(){
  d.fillStyle = "blue"
  d.fillRect(players.prota.x, players.prota.y, 50, 50)
  DesenharNome(players.prota.x, players.prota.y, players.prota.nome)
  DesenharBarraDeVida(players.prota.x, players.prota.y, players.prota.hp, players.prota.maxHp, players.prota.tamanho);
}

function DesenharInimigos(){ 
  if  (!players.inimigo) return;
  for (const enemy of players.inimigo) {

    const attr = enemy.attributos;

    d.fillStyle = "red"
    d.fillRect(attr.x, attr.y, 50, 50);
    DesenharNome(attr.x, attr.y, attr.nome ?? "Inimigo");
    DesenharBarraDeVida(attr.x, attr.y, attr.hp, attr.maxHp, attr.tamanho);
  }
}

function DesenharBarraDeVida(x, y, hp, maxHp, tamanho = 50){
const largura = 100;
const altura = 15;

const hpDivididoMaxHp = hp / maxHp;
const porcentagemDeVida = Math.max(0, Math.min(1, hpDivididoMaxHp));

const posi√ß√£oX = x + tamanho/2 - (largura / 2);
const posi√ß√£oY = y - 20;

d.fillStyle = "black";
d.fillRect(posi√ß√£oX, posi√ß√£oY, largura, altura);

d.fillStyle = "green";
d.fillRect(posi√ß√£oX, posi√ß√£oY, largura * porcentagemDeVida, altura);

d.strokeStyle = "black";

//criar linhas a cada 100 de vida
if (maxHp < 3000){
  for (let i = 1; i < maxHp / 100; i++) {
    if(i % 10 == 0  ) continue; //pular a linha do 1000
      const linhaX = posi√ß√£oX + (largura * (i * 100) / maxHp);
      d.beginPath();
      d.moveTo(linhaX, posi√ß√£oY);
      d.lineTo(linhaX, posi√ß√£oY + altura/2.5);
      d.stroke();
  }
}
//criar linhas a cada 1000 de vida
for (let i = 0; i < maxHp / 1000; i++) {
    const linhaX = posi√ß√£oX + (largura * (i * 1000) / maxHp);
    d.beginPath();
    d.moveTo(linhaX, posi√ß√£oY);
    d.lineTo(linhaX, posi√ß√£oY + altura);
    d.stroke();
}
}

function EnviarEstado(){
  ws.send(JSON.stringify({
    type: "state",
    key: key
  }))
}

function DesenharNome(x, y, nome){
  d.fillStyle = "black"
  d.font = "20px Arial"
  d.textAlign = "center"
  d.fillText(nome, x + 25, y - 30)
}

gameLoop()





</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script></body></html>
